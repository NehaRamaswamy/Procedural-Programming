# Python Programs and Patterns

This repository is a comprehensive collection of Python programs and Jupyter notebooks designed for beginners to learn and practice fundamental programming concepts. It focuses on control flow structures (like loops and conditionals), numerical patterns, asterisk-based geometric patterns, and classic algorithmic problems. The content is organized into folders for easy navigation and includes both basic exercises and more advanced variations.

Whether you're a student, self-learner, or educator, these notebooks provide hands-on examples to build skills in loops, conditionals, and problem-solving. All code is written in Python and can be run in Jupyter environments.

## Repository Structure

The repository is divided into key sections: control flow basics and miscellaneous programs. Below is an overview of the contents.

### Control Flow Structures

This section covers essential looping and conditional constructs with practical examples.

- **For Loops** (`For_loop` folder):
  - `For_cdt.ipynb`: Demonstrates for loops with conditional statements.
  - `for_range.ipynb`: Explores the `range()` function in for loops.
  - `Nested.ipynb`: Examples of nested for loops for multi-level iterations.

- **While Loops** (`While_loop` folder):
  - `while_basic.ipynb`: Basic while loop implementations for repeated execution based on conditions.

- **If Statements** (`If_statement` folder):
  - Notebooks explaining conditional execution with `if`, `elif`, and `else`.

### Programs

This folder contains standalone notebooks solving common numerical and logical problems. These are classic exercises to reinforce concepts like recursion, modulo operations, and digit manipulation.

- `armstrong.ipynb`: Checks if a number is an Armstrong number (sum of cubes of digits equals the number).
- `binary.ipynb`: Converts numbers to binary representation.
- `composite_num.ipynb`: Identifies composite numbers (integers greater than 1 with more than two factors).
- `disarum.ipynb`: Checks for Disarium numbers (sum of digits raised to their position powers equals the number).
- `Evilodi.ipynb`: Finds Evil numbers (even number of 1s in binary representation).
- `factors.ipynb`: Lists all factors of a given number.
- `Factorial.ipynb`: Computes the factorial of a number (e.g., \$ n! \$).
- `fizzbuzz.ipynb` / `FizzBuzz.ipynb`: Prints "Fizz" for multiples of 3, "Buzz" for multiples of 5, and "FizzBuzz" for both.
- `Happy.ipynb`: Determines if a number is happy (repeatedly sums squares of digits until reaching 1).
- `integer.ipynb`: Basic operations on integers.
- `lcm.ipynb`: Calculates the least common multiple (LCM) of two or more numbers.
- `palindrom.ipynb` / `palindrome.ipynb`: Checks if a number or string reads the same forwards and backwards.
- `Perfect.ipynb`: Identifies perfect numbers (sum of proper divisors equals the number).
- `Poly_prime.ipynb`: Explores polyprimes or palindromic primes.
- `Prime_num.ipynb`: Checks if a number is prime and finds primes in a range.
- `reverse.ipynb`: Reverses a number or string.
- `strong.ipynb`: Checks for strong numbers (factorial of digits sum equals the number).
- `Sum_digits.ipynb`: Sums the digits of a number.
- `Sum_even.ipynb`: Calculates the sum of even numbers in a range.
- `EMIRP.ipynb`: Finds Emirp numbers (primes that remain prime when digits are reversed, e.g., 13 â†’ 31).

And more programs for additional challenges!


## Learning Outcomes

- Master loops (`for`, `while`, nested) and conditionals (`if-else`).
- Solve algorithmic problems like primality, palindromes, and factorials.
- Practice debugging and optimization in Python.
